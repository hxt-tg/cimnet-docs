<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>关于 C++ 语言 &mdash; CimNet 0.1.4 文档</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/translations.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="开发者协议" href="credits-license.html" />
    <link rel="prev" title="常用网络" href="reference/impl-networks.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #d44a1c" >
            <a href="index.html" class="icon icon-home"> CimNet
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">文档目录</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">安装 CimNet</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">CimNet 使用说明</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference/intro.html">CimNet 参考文档</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">关于 C++ 语言</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#object-oriented">面向对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="#instantiation-and-template-class">实例化与模板类</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pointer-and-reference">对象的指针与引用</a></li>
<li class="toctree-l2"><a class="reference internal" href="#looping-on-stl">标准容器类的遍历</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inherit">继承</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="credits-license.html">开发者协议</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单"  style="background: #d44a1c" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CimNet</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">关于 C++ 语言</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="c">
<span id="cimnet-about-cpp"></span><h1>关于 C++ 语言<a class="headerlink" href="#c" title="此标题的永久链接"></a></h1>
<p>这一部分的内容将帮助你在仅有C语言基础的条件下，快速学习使用 CimNet 所必需的 C++ 语法。此外，阅读 CimNet <code class="file docutils literal notranslate"><span class="pre">example/</span></code> 文件夹中提供的例子也能够增加你对语言特性的理解。注意，这里只介绍一些最基本的概念，如果你希望实现一些更加高级的特性，需要额外学习一些专业书籍。</p>
<section id="object-oriented">
<span id="id1"></span><h2>面向对象<a class="headerlink" href="#object-oriented" title="此标题的永久链接"></a></h2>
<p>大多数支持面向对象编程的语言拥有四大特性——封装，抽象，继承，多态。</p>
<p>封装和抽象保证了程序模块和模块之间的高度独立和易用。在你使用这个对象的时候，可以不必关心对象的实现细节，使你更加关注程序其他部分的逻辑。你可以使用更加表意的方式修改对象数据，并且保证数据修改的可靠和合理。</p>
<p>在 CimNet 中， <code class="file docutils literal notranslate"><span class="pre">cimnet/network.h</span></code> 中所有网络类都继承于 <a class="reference internal" href="reference/network.html#_CPPv4I000E7Network" title="Network"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Network</span></code></a> 类，这意味着你可以在例如 <a class="reference internal" href="reference/impl-networks.html#_CPPv4I00E14RegularNetwork" title="RegularNetwork"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">RegularNetwork</span></code></a> 的对象中访问 <a class="reference internal" href="reference/network.html#_CPPv4I000E7Network" title="Network"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Network</span></code></a> 的方法。其中 <a class="reference internal" href="reference/impl-networks.html#_CPPv4I00E14RegularNetwork" title="RegularNetwork"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">RegularNetwork</span></code></a> 称为子类， <a class="reference internal" href="reference/network.html#_CPPv4I000E7Network" title="Network"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Network</span></code></a> 称为父类或基类。</p>
</section>
<section id="instantiation-and-template-class">
<span id="id2"></span><h2>实例化与模板类<a class="headerlink" href="#instantiation-and-template-class" title="此标题的永久链接"></a></h2>
<p>在 C++ 中，一个类可以实例化一个对象，每一个对象都能访问这个类中的方法，但是对象与对象之间的大部分数据并不共通。所谓方法就是函数，不过这个函数只能针对特定类实例化的对象来调用。你可以使用 <code class="docutils literal notranslate"><span class="pre">ClassName</span> <span class="pre">var;</span></code> 来实例化对象 <code class="docutils literal notranslate"><span class="pre">var</span></code> ，使用 <code class="docutils literal notranslate"><span class="pre">var.method(params,</span> <span class="pre">...)</span></code> 来调用 <code class="docutils literal notranslate"><span class="pre">ClassName</span></code> 的方法。</p>
<p>C++ 提供了一种更加高级的方式来实现一些功能相似但数据类型不一致的类，即模板类。模板类所实现类需要指定一些模板参数，这些模板参数就是指定的数据类型。模板类里会实现针对给定模板参数的属性和方法。使用模板类的语法是在类名后加尖括号，即 <code class="docutils literal notranslate"><span class="pre">ClassName&lt;ClassParams,</span> <span class="pre">...&gt;</span></code> ，并且用这个模板类实例化所需的对象。这里有一个语法陷阱，如果你想使用一个全部取默认的模板参数的模板类，在 C++11 的标准下类名后的尖括号是不能省略的，即 <code class="docutils literal notranslate"><span class="pre">ClassName&lt;&gt;</span></code> 。</p>
<p>以 CimNet 的 <a class="reference internal" href="reference/network.html#_CPPv4I000E7Network" title="Network"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Network</span></code></a> 为例：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Network</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">net</span><span class="p">;</span><span class="w"></span>
<span class="n">net</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>上例中第一行实例化了一个 <a class="reference internal" href="reference/network.html#_CPPv4I000E7Network" title="Network"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Network</span></code></a> 类的空实例 <span class="cpp-expr sig sig-inline cpp"><span class="n">net</span></span> ，这个模板类接受了三个模板参数。第二行调用了 <a class="reference internal" href="reference/network.html#_CPPv4I000E7Network" title="Network"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Network</span></code></a> 中的 <a class="reference internal" href="reference/network.html#_CPPv4N7Network8add_edgeERK4_NIdRK4_NIdRK6_EData" title="Network::add_edge"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">add_edge</span></code></a> 方法来修改网络 <span class="cpp-expr sig sig-inline cpp"><span class="n">net</span></span> ，你不能直接修改实现网络的数据结构，只能通过提供的接口来访问内部的数据结构，这些接口会保证进行的修改是合理有效的，一定程度上保证了网络不会出现意外的错误。</p>
</section>
<section id="pointer-and-reference">
<span id="id3"></span><h2>对象的指针与引用<a class="headerlink" href="#pointer-and-reference" title="此标题的永久链接"></a></h2>
<p>类似 C 语言中的语法，你可以创建一个对象的指针，手动创建它的内存空间，并且在使用完毕后释放。上例也可以写成如下形式：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">Network</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MyNetwork</span><span class="p">;</span><span class="w"></span>
<span class="n">MyNetwork</span><span class="w"> </span><span class="o">*</span><span class="n">net</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyNetwork</span><span class="p">;</span><span class="w"></span>
<span class="n">net</span><span class="o">-&gt;</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="k">delete</span><span class="w"> </span><span class="n">net</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">typedef</span></code> 语句来简化对模板类的表达。程序的第二行实例化了一个 <a class="reference internal" href="reference/network.html#_CPPv4I000E7Network" title="Network"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Network</span></code></a> 对象，分配了它的内存空间，初始化它为一个空的网络，并把它的地址赋值给指针变量 <span class="cpp-expr sig sig-inline cpp"><span class="n">net</span></span> 。 <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">ClassName(params,</span> <span class="pre">...)</span></code> 后的初始化参数列表可以省略，它会在初始化的时候调用默认构造器。指针变量的方法使用 <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">.</span></code> 访问。最后使用 <code class="docutils literal notranslate"><span class="pre">delete</span></code> 语句释放 <span class="cpp-expr sig sig-inline cpp"><span class="n">net</span></span> 的内存。需要注意的是，你要保证程序逻辑里的每一个被 <code class="docutils literal notranslate"><span class="pre">new</span></code> 创建的对象都被 <code class="docutils literal notranslate"><span class="pre">delete</span></code> 释放，不然会造成大量内存泄漏。</p>
<p>如果你需要在函数间传递对象，又要避免参数拷贝浪费的时间，建议使用引用。引用可以让你像使用原始变量一样使用引用变量，同时不会占用额外空间和拷贝时间——你修改的就是原始变量。某种意义上，引用变量是原始变量的一个别名。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">typedef</span><span class="w"> </span><span class="n">Network</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MyNetwork</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kt">void</span><span class="w"> </span><span class="nf">print_degree_ref</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyNetwork</span><span class="w"> </span><span class="o">&amp;</span><span class="n">net</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">.</span><span class="n">total_degree</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="kt">void</span><span class="w"> </span><span class="nf">print_degree_ptr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyNetwork</span><span class="w"> </span><span class="o">*</span><span class="n">net</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">net</span><span class="o">-&gt;</span><span class="n">total_degree</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 9</span><span class="p">}</span><span class="w"></span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">12</span><span class="w">    </span><span class="n">MyNetwork</span><span class="w"> </span><span class="n">net</span><span class="p">;</span><span class="w"></span>
<span class="linenos">13</span><span class="w">    </span><span class="n">net</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="linenos">14</span><span class="w">    </span><span class="n">print_degree_ref</span><span class="p">(</span><span class="n">net</span><span class="p">);</span><span class="w"></span>
<span class="linenos">15</span><span class="w">    </span><span class="n">print_degree_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="p">);</span><span class="w"></span>
<span class="linenos">16</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">17</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>程序用两种方式定义了打印网络总度数的函数。参数列表前的 <code class="docutils literal notranslate"><span class="pre">const</span></code> 保证变量不会在函数内部被改变。两个函数参数中的变量 <span class="cpp-expr sig sig-inline cpp"><span class="n">net</span></span> 都指代 <span class="cpp-expr sig sig-inline cpp"><span class="n">main</span></span> 函数里的网络变量 <span class="cpp-expr sig sig-inline cpp"><span class="n">net</span></span> ，都不会对整个变量进行拷贝，只不过一种是用指针方式，一种是用引用方式。你可以从这个例子中感受这两种方式的差异。</p>
</section>
<section id="looping-on-stl">
<span id="id4"></span><h2>标准容器类的遍历<a class="headerlink" href="#looping-on-stl" title="此标题的永久链接"></a></h2>
<p>C++11 提供了大量模板容器类便于你存储各种结构的数据，我们以最常用的一种容器介绍 C++11 的语言特性。</p>
<p><span class="cpp-expr sig sig-inline cpp"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></span> 是标准库提供的一种动态数组容器，以下是一个使用的例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="p">;</span><span class="w"></span>
<span class="n">array</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;Data 1&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">array</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;Data 2&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">array</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;Data 3&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><span class="cpp-expr sig sig-inline cpp"><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">&gt;</span></span> 表示这个容器是用来装字符串类型的。 <span class="cpp-expr sig sig-inline cpp"><span class="n">array</span></span> 中依次插入了三个字符串。你可以用 <span class="cpp-expr sig sig-inline cpp"><span class="n">array</span><span class="p">[</span><span class="m">2</span><span class="p">]</span></span> 访问字符串 <span class="cpp-expr sig sig-inline cpp"><span class="s">&quot;Data 3&quot;</span></span> 。如果你想遍历这个容器，常用的方式是这样：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>C++11 提供了一种更方便的方式遍历容器：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>与 C 语言中的 <span class="cpp-expr sig sig-inline cpp"><span class="kt">auto</span></span> 不同， C++ 的 <span class="cpp-expr sig sig-inline cpp"><span class="kt">auto</span></span> 表达的是对此处变量类型的推导。也就是此处不需要显示指明变量 <span class="cpp-expr sig sig-inline cpp"><span class="n">s</span></span> 的类型，编译器可以自行推导。与上文介绍的引用变量一样，这里的 <span class="cpp-expr sig sig-inline cpp"><span class="n">s</span></span> 也是引用，是容器内存储元素的引用，它在遍历过程中也可以不占用额外空间地快速访问 <span class="cpp-expr sig sig-inline cpp"><span class="n">array</span></span> 中的元素。（事实上这种遍历方式是通过访问容器迭代器 <span class="cpp-expr sig sig-inline cpp"><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="n">_Type</span><span class="p">&gt;</span><span class="p">::</span><span class="n">iterator</span></span> 实现的，它是 C++11 的一个协议式语法糖，不过这里不再讨论其实现细节，只需要知道这种遍历方式十分方便即可。） <a class="reference internal" href="reference/network.html#_CPPv4I000E7Network" title="Network"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Network</span></code></a> 类中的 <a class="reference internal" href="reference/network.html#_CPPv4NK7Network9neighborsERK4_NId" title="Network::neighbors"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">neighbors(NodeId</span> <span class="pre">id)</span></code></a> 方法返回的就是一个 <span class="cpp-expr sig sig-inline cpp"><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="n">NodeId</span><span class="p">&gt;</span></span> ，你可以用一个新的 <span class="cpp-expr sig sig-inline cpp"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></span> 接住这个返回值，也可以用它直接遍历：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">neighbor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">net</span><span class="p">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">id</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">neighbor</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="inherit">
<span id="id5"></span><h2>继承<a class="headerlink" href="#inherit" title="此标题的永久链接"></a></h2>
<p>谈到继承机制，就涉及到 C++ 的高级语法部分了，在该文档内难以赘述。此处提供一个最基础的继承代码范式，你可以替换其中的部分内容完成对 CimNet 网络基类的继承。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyNetwork</span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Network</span><span class="o">&lt;</span><span class="n">NodeId</span><span class="p">,</span><span class="w"> </span><span class="n">NodeData</span><span class="p">,</span><span class="w"> </span><span class="n">EdgeData</span><span class="o">&gt;</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">MyNetwork</span><span class="p">(</span><span class="n">params</span><span class="p">...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Implementation</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>你可以将上面的 <span class="cpp-expr sig sig-inline cpp"><span class="n">MyNetwork</span></span> 替换为你的网络类名，在 <span class="cpp-expr sig sig-inline cpp"><span class="n">NodeId</span></span> ， <span class="cpp-expr sig sig-inline cpp"><span class="n">NodeData</span></span> 和 <span class="cpp-expr sig sig-inline cpp"><span class="n">EdgeData</span></span> 处分别填写网络中存储的 <code class="docutils literal notranslate"><span class="pre">节点编号类型</span></code> ， <code class="docutils literal notranslate"><span class="pre">节点数据</span></code> 和 <code class="docutils literal notranslate"><span class="pre">边数据</span></code> 。在 <code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">Implementation</span></code> 处编写网络的具体实现。如果你需要编写一个带模板语法的继承，或是在子类中添加独有的属性和方法，可以学习参考 <code class="file docutils literal notranslate"><span class="pre">cimnet/network.h</span></code> 中的实现或联系开发者。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="reference/impl-networks.html" class="btn btn-neutral float-left" title="常用网络" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="credits-license.html" class="btn btn-neutral float-right" title="开发者协议" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, @hxt-tg.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>